{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"A site to keep coding related content. It's a living collection of best practices and stuff which I gathered over the years. The content of this site may or may not be complete, correct or useful to you. The content is kept minimalistic on purpose. Nice and Shiny","title":"About"},{"location":"architecture/architecture/","text":"Archtecture Eine Architektur braucht eine Vision (und ist auf das Business fokussiert). Know whether to use a tool or technology (and only partially how) Goal Technical decisions to deliver features efficient and effective - and close the feedback loop fast Most simple ( and not most flexible ) solution for the problem to solve Emergent Architecture Emergent Architecture basiert auf einem stabilen Kern Viele Architekturentscheide k\u00f6nnen aufgeschoben , \u200b und lokal anstatt zentral get\u00e4tigt warden.\u200b Gewisse Entscheide m\u00fcssen fr\u00fch getroffen werden:\u200b Wie soll das System aussehen ( \u00dcbersicht , Vision )\u200b Wo sind die Hauptabstraktionen\u200b Wie soll das Projektteam/System strukturiert sein (Conway\u2019s Law)\u200b Der Kern der Emergenten Architektur soll so stabil wie m\u00f6glich sein. Er wird abgeleitet aus der Art des Gesch\u00e4fts .\u200b Der Kern hat meist hohe Kosten f\u00fcr \u00c4nderung oder ihn r\u00fcckg\u00e4ngig zu machen. Architekturentscheide Faktoren f\u00fcr die Frage wann Architekturentscheide gemacht werden sollen. * was kostet eine versp\u00e4tete Entscheidung? * was kostet es zum R\u00fcckg\u00e4ngig machen der Entscheidung? * werden zuk\u00fcnftige Perspektiven verhindert? * Ist schnelles Feedback verf\u00fcgbar? Patterns Strangler (Fig) Pattern Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new applications and services. As features from the legacy system are replaced, the new system eventually replaces all of the old system's features, strangling the old system and allowing you to decommission it. \ud83d\udca1 Use this pattern when gradually migrating a back-end application to a new architecture. Anti-Corruption Layer Legacy systems often suffer from quality issues such as convoluted data schemas or obsolete APIs. A Facade helps to keep the interface of a new Application clean. \ud83d\udca1 Use this pattern to ensure that an application's design is not limited by dependencies on outside subsystems.","title":"Archtecture"},{"location":"architecture/architecture/#archtecture","text":"Eine Architektur braucht eine Vision (und ist auf das Business fokussiert). Know whether to use a tool or technology (and only partially how)","title":"Archtecture"},{"location":"architecture/architecture/#goal","text":"Technical decisions to deliver features efficient and effective - and close the feedback loop fast Most simple ( and not most flexible ) solution for the problem to solve","title":"Goal"},{"location":"architecture/architecture/#emergent-architecture","text":"Emergent Architecture basiert auf einem stabilen Kern Viele Architekturentscheide k\u00f6nnen aufgeschoben , \u200b und lokal anstatt zentral get\u00e4tigt warden.\u200b Gewisse Entscheide m\u00fcssen fr\u00fch getroffen werden:\u200b Wie soll das System aussehen ( \u00dcbersicht , Vision )\u200b Wo sind die Hauptabstraktionen\u200b Wie soll das Projektteam/System strukturiert sein (Conway\u2019s Law)\u200b Der Kern der Emergenten Architektur soll so stabil wie m\u00f6glich sein. Er wird abgeleitet aus der Art des Gesch\u00e4fts .\u200b Der Kern hat meist hohe Kosten f\u00fcr \u00c4nderung oder ihn r\u00fcckg\u00e4ngig zu machen.","title":"Emergent Architecture"},{"location":"architecture/architecture/#architekturentscheide","text":"Faktoren f\u00fcr die Frage wann Architekturentscheide gemacht werden sollen. * was kostet eine versp\u00e4tete Entscheidung? * was kostet es zum R\u00fcckg\u00e4ngig machen der Entscheidung? * werden zuk\u00fcnftige Perspektiven verhindert? * Ist schnelles Feedback verf\u00fcgbar?","title":"Architekturentscheide"},{"location":"architecture/architecture/#patterns","text":"","title":"Patterns"},{"location":"architecture/architecture/#strangler-fig-pattern","text":"Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new applications and services. As features from the legacy system are replaced, the new system eventually replaces all of the old system's features, strangling the old system and allowing you to decommission it. \ud83d\udca1 Use this pattern when gradually migrating a back-end application to a new architecture.","title":"Strangler (Fig) Pattern"},{"location":"architecture/architecture/#anti-corruption-layer","text":"Legacy systems often suffer from quality issues such as convoluted data schemas or obsolete APIs. A Facade helps to keep the interface of a new Application clean. \ud83d\udca1 Use this pattern to ensure that an application's design is not limited by dependencies on outside subsystems.","title":"Anti-Corruption Layer"},{"location":"architecture/database/","text":"Datenarchitektur Folgende Punkte sind entscheidende Themen bzw. Fragen zur Datenarchitektur: SQL oder NoSQL? Datenzugriff (API, ORM) Authentisierung und Autorisierung des Datenbankzugriffs (simpel oder komplex) Datenbank-Updates (transitions- oder zustandsbasiert und Wahl des Werkzeugs) Datenbanktests und Testdaten (Anonymisierung) Datenmigration und -abgleich (Big Bang oder Koexistenz) Datenexport f\u00fcr Datahub Cross-Boundary Data Access Pattern (Web Gateway, Data Aggregator, Service-to-Service, Materialized View) Event Driven Architecture (Event Sourcing, CQRS, Event Notification, Event-Carried State Transfer) Datenschutz, Kryptographie und Compliance (GDPR) Data Dictionary: Auswahl des Werkzeugs (Microsoft Azure Data Catalog?) \u00c4nderungsverfolgung (Audit Trail, temporale Datenbank, Document-Versioning-Pattern) Verf\u00fcgbarkeit Master Data Management Datenqualit\u00e4t Datenbank-Backup und -Retention Datenredundanz (Datenreplikation, Materialized Views) Bulk Data Exchange Datenkonsistenz (verteilte Transaktionen, SAGA)","title":"Datenarchitektur"},{"location":"architecture/database/#datenarchitektur","text":"Folgende Punkte sind entscheidende Themen bzw. Fragen zur Datenarchitektur: SQL oder NoSQL? Datenzugriff (API, ORM) Authentisierung und Autorisierung des Datenbankzugriffs (simpel oder komplex) Datenbank-Updates (transitions- oder zustandsbasiert und Wahl des Werkzeugs) Datenbanktests und Testdaten (Anonymisierung) Datenmigration und -abgleich (Big Bang oder Koexistenz) Datenexport f\u00fcr Datahub Cross-Boundary Data Access Pattern (Web Gateway, Data Aggregator, Service-to-Service, Materialized View) Event Driven Architecture (Event Sourcing, CQRS, Event Notification, Event-Carried State Transfer) Datenschutz, Kryptographie und Compliance (GDPR) Data Dictionary: Auswahl des Werkzeugs (Microsoft Azure Data Catalog?) \u00c4nderungsverfolgung (Audit Trail, temporale Datenbank, Document-Versioning-Pattern) Verf\u00fcgbarkeit Master Data Management Datenqualit\u00e4t Datenbank-Backup und -Retention Datenredundanz (Datenreplikation, Materialized Views) Bulk Data Exchange Datenkonsistenz (verteilte Transaktionen, SAGA)","title":"Datenarchitektur"},{"location":"architecture/microservices/","text":"Design patterns for microservices Microsoft \"Design patterns for microservices\"","title":"Design patterns for microservices"},{"location":"architecture/microservices/#design-patterns-for-microservices","text":"Microsoft \"Design patterns for microservices\"","title":"Design patterns for microservices"},{"location":"azure/azure/","text":"Azure Functions vs Azure Logic Apps Azure Functions is a serverless compute service. Azure Logic Apps provides serverless workflows . Both can create complex orchestrations. When dealing with synchronous request/response calls, that execute more complex logic, Azure Functions is the preferred option. Logic Apps is better suited for asynchronous integration and fire-and-forget messaging that requires reliable processing. When using Logic Apps, they can be perfectly extended with Azure Functions to execute stateless tasks that cannot be fulfilled by the out-of-the-box Logic Apps capabilities. Durable Functions Logic Apps Development Code-first (imperative) Designer-first (declarative) Connectivity About a dozen built-in binding types, write code for custom bindings Large collection of connectors, Enterprise Integration Pack for B2B scenarios, build custom connectors Actions Each activity is an Azure function; write code for activity functions Large collection of ready-made actions Monitoring Azure Application Insights Azure portal, Azure Monitor logs Management REST API, Visual Studio Azure portal, REST API, PowerShell, Visual Studio Execution context Can run locally or in the cloud Runs only in the cloud","title":"Azure Functions vs Azure Logic Apps"},{"location":"azure/azure/#azure-functions-vs-azure-logic-apps","text":"Azure Functions is a serverless compute service. Azure Logic Apps provides serverless workflows . Both can create complex orchestrations. When dealing with synchronous request/response calls, that execute more complex logic, Azure Functions is the preferred option. Logic Apps is better suited for asynchronous integration and fire-and-forget messaging that requires reliable processing. When using Logic Apps, they can be perfectly extended with Azure Functions to execute stateless tasks that cannot be fulfilled by the out-of-the-box Logic Apps capabilities. Durable Functions Logic Apps Development Code-first (imperative) Designer-first (declarative) Connectivity About a dozen built-in binding types, write code for custom bindings Large collection of connectors, Enterprise Integration Pack for B2B scenarios, build custom connectors Actions Each activity is an Azure function; write code for activity functions Large collection of ready-made actions Monitoring Azure Application Insights Azure portal, Azure Monitor logs Management REST API, Visual Studio Azure portal, REST API, PowerShell, Visual Studio Execution context Can run locally or in the cloud Runs only in the cloud","title":"Azure Functions vs Azure Logic Apps"},{"location":"dotNet/constStaticReadonly/","text":"Const vs Static vs Readonly Here's what you need to know about using const , static , and readonly : If you know the value will never, ever, ever change for any reason, use const . (Other Assemblies that use this value need to be recompiled before they get the new value) If you're unsure of whether or not the value will change, but you don't want other classes or code to be able to change it, use readonly . If you need a field to be a property of a type, and not a property of an instance of that type, use static . A const value is also implicitly static .","title":"Const vs Static vs Readonly"},{"location":"dotNet/constStaticReadonly/#const-vs-static-vs-readonly","text":"Here's what you need to know about using const , static , and readonly : If you know the value will never, ever, ever change for any reason, use const . (Other Assemblies that use this value need to be recompiled before they get the new value) If you're unsure of whether or not the value will change, but you don't want other classes or code to be able to change it, use readonly . If you need a field to be a property of a type, and not a property of an instance of that type, use static . A const value is also implicitly static .","title":"Const vs Static vs Readonly"},{"location":"dotNet/functionalApproach/","text":"Functional approach Can improve: Predictability Maintainability Testability Taming side effects Side effects make the code more difficult to test and reason about We can reduce side effects by enforcing immutability public class NoSideEffects { // no setter => value cannot change public int Result { get; } constructor(int value) { Result = value; } public NoSideEffects Add(int value) { // return a new object to prevent side effects return new NoSideEffects(Result + value); } } Emphasizing expressions Can simplify code by always returning a value Allows piping by method chaining Statements Have side effects string result; if(number >= 0) { result = \"positiv\" } else { result = \"negative\" } Expressions Always return a value and have not side effects Expressions can be called once or any number of times and they will produce the same result, for a given input. Expressions are easier to test var result = number >= 0 ? \"positiv\" : \"negative\" Expression Methods public static partial class FuncExtensions { public static TResult Map<T, TResult>(this T value, Func<T, TResult> function) => function(value); } public static partial class ActionExtensions { public static void Do<T>(this T value, Action<T> function) => function(value); } internal static void Calculate() { \"-2\".Map(int.Parse) // string -> int .Map(Math.Abs) // int -> int .Map(Convert.ToDouble) // int -> double .Map(Math.Sqrt) // double -> double .Do(Console.WriteLine); // double -> void // Equivalent to: Console.WriteLine(Math.Sqrt(Convert.ToDouble(Math.Abs(int.Parse(\"-2\"))))); // or string input = \"-2.0\"; int output1 = int.Parse(input); // string -> int int output2 = Math.Abs(output1); // int -> int double output3 = Convert.ToDouble(output2); // int -> double double output4 = Math.Sqrt(output3); // double -> double Console.WriteLine(output4); // double -> void }","title":"Functional Approach"},{"location":"dotNet/functionalApproach/#functional-approach","text":"Can improve: Predictability Maintainability Testability","title":"Functional approach"},{"location":"dotNet/functionalApproach/#taming-side-effects","text":"Side effects make the code more difficult to test and reason about We can reduce side effects by enforcing immutability public class NoSideEffects { // no setter => value cannot change public int Result { get; } constructor(int value) { Result = value; } public NoSideEffects Add(int value) { // return a new object to prevent side effects return new NoSideEffects(Result + value); } }","title":"Taming side effects"},{"location":"dotNet/functionalApproach/#emphasizing-expressions","text":"Can simplify code by always returning a value Allows piping by method chaining","title":"Emphasizing expressions"},{"location":"dotNet/functionalApproach/#statements","text":"Have side effects string result; if(number >= 0) { result = \"positiv\" } else { result = \"negative\" }","title":"Statements"},{"location":"dotNet/functionalApproach/#expressions","text":"Always return a value and have not side effects Expressions can be called once or any number of times and they will produce the same result, for a given input. Expressions are easier to test var result = number >= 0 ? \"positiv\" : \"negative\"","title":"Expressions"},{"location":"dotNet/functionalApproach/#expression-methods","text":"public static partial class FuncExtensions { public static TResult Map<T, TResult>(this T value, Func<T, TResult> function) => function(value); } public static partial class ActionExtensions { public static void Do<T>(this T value, Action<T> function) => function(value); } internal static void Calculate() { \"-2\".Map(int.Parse) // string -> int .Map(Math.Abs) // int -> int .Map(Convert.ToDouble) // int -> double .Map(Math.Sqrt) // double -> double .Do(Console.WriteLine); // double -> void // Equivalent to: Console.WriteLine(Math.Sqrt(Convert.ToDouble(Math.Abs(int.Parse(\"-2\"))))); // or string input = \"-2.0\"; int output1 = int.Parse(input); // string -> int int output2 = Math.Abs(output1); // int -> int double output3 = Convert.ToDouble(output2); // int -> double double output4 = Math.Sqrt(output3); // double -> double Console.WriteLine(output4); // double -> void }","title":"Expression Methods"},{"location":"frontend/","text":"Angular Firebase Rxjs NgRx","title":"JS"},{"location":"frontend/angular/","text":"Angular Structoring Components Smart (Container) Components A Smart Component has external dependencies or causes side effects (but still might or might not have a local state). Knows stuff about the use-case (feature) Dumb (Presentational) Components A Dumb Component has no external dependencies and causes no side effects (but still might or might not have a local state). Doesn't care about a specific use-case (feature) but it supports it anyway (e.g.: displaying an adress. This component might support multiple use-cases) Guidelines for dumb components: Should not be dependant on external services \u200a\u2014\u200aif it requires some data to work, it should be injected via @Input() ; Should not produce any side effects \u200a\u2014\u200aif it needs to emit something, it should be emitted with @Output() instead; Should not mutate its\u2019 inputs \u200a\u2014\u200abecause if it does, it actually produces a side effect that causes a change in the parent component\u2019s data. Try to use dumb components as much as possible! They make your application less complex and easier to reason about. If it can be Dumb, make it Dumb Async as use async as syntax as much as possible (reduces subscriptions / stream calls / complexity) <div *ngIf=\"(user$ | async) as user\"> {user.name}} </div> NgIf Else *ngIf=\"value\"; else notValue as an easy alternative to *ngIf=\"!value\" <div *ngIf=\"isLoggedIn; else loggedOut\"> Welcome back, friend. </div> <ng-template #loggedOut> Please friend, login. </ng-template> Input with observables Pass values to components instead of observables to reduce coupling If observables are passed to a component a child component might trigger something in the parent component. Imagine a parent component defining an observable like this users$ = this.http.get(...); When the user$ gets passed to a child component which then subscribes to it this.user$.subscribe(u => this.user = u); The child triggers (unknowingly / unwanted) HTTP requests Same is valid for service calls. Instead of filteredusers$ = this.fooService.filterUsers(this.users$); Better do filteredusers$ = this.users$.pipe(switchMap(users => this.fooService.filterUsers(users))); Performance issues in Angular Debugging Performance Problems in Angular: Add debug() to html template a. Log something like \u2018..rendering..\u2019 If too many renderings happen (some might happen) => Add Breakpoint Go down the StackTrace and look for \u201cOnInvokeTask\u201d => Add Breakpoint Take a look at the \u201ctask\u201d-Property it might contain some infos about the function which lead to the re-rendering (e.g.: see callbackFun) ??? Profit Best Practices Angular Do not use myfunc.bind(this) in HTML-Template. Why? It creates a new function for every rendering. Try to minimize the use of functions in HTML-Template. Why? They get executed for every rendering. Do replace functions (in template) with (pure) pipes. Why? Function calls made from a template are invoked every time a change occures (no caching) => getting called very often. Why? Pipes are only called when inputs (to pipe function) are changed. Consider Using Memo Decorator (npm package) to cache pipe outputs. Do use trackBy along with ngFor. Why? When an array changes, Angular re-renders the whole DOM tree. But when you use trackBy, Angular will know which element has changed and will only make DOM changes only for that element. Do use aliases for importing modules or libraries. Typescript Do define DTOs as interfaces instead of classes. Why? A class generates code since it is primarily syntactical sugar over JavaScript\u2019s existing prototype-based inheritance. Why? An interface does not generate code since it is a virtual structures that only exist within the context of TypeScript.","title":"Angular"},{"location":"frontend/angular/#angular","text":"","title":"Angular"},{"location":"frontend/angular/#structoring-components","text":"","title":"Structoring Components"},{"location":"frontend/angular/#smart-container-components","text":"A Smart Component has external dependencies or causes side effects (but still might or might not have a local state). Knows stuff about the use-case (feature)","title":"Smart (Container) Components"},{"location":"frontend/angular/#dumb-presentational-components","text":"A Dumb Component has no external dependencies and causes no side effects (but still might or might not have a local state). Doesn't care about a specific use-case (feature) but it supports it anyway (e.g.: displaying an adress. This component might support multiple use-cases) Guidelines for dumb components: Should not be dependant on external services \u200a\u2014\u200aif it requires some data to work, it should be injected via @Input() ; Should not produce any side effects \u200a\u2014\u200aif it needs to emit something, it should be emitted with @Output() instead; Should not mutate its\u2019 inputs \u200a\u2014\u200abecause if it does, it actually produces a side effect that causes a change in the parent component\u2019s data. Try to use dumb components as much as possible! They make your application less complex and easier to reason about. If it can be Dumb, make it Dumb","title":"Dumb (Presentational) Components"},{"location":"frontend/angular/#async-as","text":"use async as syntax as much as possible (reduces subscriptions / stream calls / complexity) <div *ngIf=\"(user$ | async) as user\"> {user.name}} </div>","title":"Async as"},{"location":"frontend/angular/#ngif-else","text":"*ngIf=\"value\"; else notValue as an easy alternative to *ngIf=\"!value\" <div *ngIf=\"isLoggedIn; else loggedOut\"> Welcome back, friend. </div> <ng-template #loggedOut> Please friend, login. </ng-template>","title":"NgIf Else"},{"location":"frontend/angular/#input-with-observables","text":"Pass values to components instead of observables to reduce coupling If observables are passed to a component a child component might trigger something in the parent component. Imagine a parent component defining an observable like this users$ = this.http.get(...); When the user$ gets passed to a child component which then subscribes to it this.user$.subscribe(u => this.user = u); The child triggers (unknowingly / unwanted) HTTP requests Same is valid for service calls. Instead of filteredusers$ = this.fooService.filterUsers(this.users$); Better do filteredusers$ = this.users$.pipe(switchMap(users => this.fooService.filterUsers(users)));","title":"Input with observables"},{"location":"frontend/angular/#performance-issues-in-angular","text":"Debugging Performance Problems in Angular: Add debug() to html template a. Log something like \u2018..rendering..\u2019 If too many renderings happen (some might happen) => Add Breakpoint Go down the StackTrace and look for \u201cOnInvokeTask\u201d => Add Breakpoint Take a look at the \u201ctask\u201d-Property it might contain some infos about the function which lead to the re-rendering (e.g.: see callbackFun) ??? Profit","title":"Performance issues in Angular"},{"location":"frontend/angular/#best-practices","text":"","title":"Best Practices"},{"location":"frontend/angular/#angular_1","text":"Do not use myfunc.bind(this) in HTML-Template. Why? It creates a new function for every rendering. Try to minimize the use of functions in HTML-Template. Why? They get executed for every rendering. Do replace functions (in template) with (pure) pipes. Why? Function calls made from a template are invoked every time a change occures (no caching) => getting called very often. Why? Pipes are only called when inputs (to pipe function) are changed. Consider Using Memo Decorator (npm package) to cache pipe outputs. Do use trackBy along with ngFor. Why? When an array changes, Angular re-renders the whole DOM tree. But when you use trackBy, Angular will know which element has changed and will only make DOM changes only for that element. Do use aliases for importing modules or libraries.","title":"Angular"},{"location":"frontend/angular/#typescript","text":"Do define DTOs as interfaces instead of classes. Why? A class generates code since it is primarily syntactical sugar over JavaScript\u2019s existing prototype-based inheritance. Why? An interface does not generate code since it is a virtual structures that only exist within the context of TypeScript.","title":"Typescript"},{"location":"frontend/css/","text":"px, em, rem? Use em only for sizing that needs to scale based on the font size of an element other than the html (root) element. Use rem unit for elements that scale depending on a user's browser font size settings. Use rem as the unit for most of your property value. For complex layout arrangement, use percentage ( % ). User can change the font-size within the browser setting (difficult to find). This has no effect if px are used (main reason to discard px ?) Pixels are ignorant, don\u2019t use them. ? Use rem for sizes and spacing. rem and em units are computed into pixel values by the browser, based on font sizes in your design. em units are based on the font size of the element they\u2019re used on. rem units are based on the font size of the html element. em units can be influenced by font size inheritance from any parent element rem units can be influenced by font size inheritance from browser font settings. Use em units for sizing that should scale depending on the font size of an element other than the root. Use rem units for sizing that doesn\u2019t need em units, and that should scale depending on browser font size settings. Use rem units unless you\u2019re sure you need em units, including on font sizes. Use rem ? em ? units on media queries. Found both as best practices ( em seems also to work with safari) Don\u2019t use em or rem in multi column layout widths - use % instead. Don\u2019t use em or rem if scaling would unavoidably cause a layout element to break. Tip When creating layouts it\u2019s often easier to think in pixels but output in rem units. You can have pixel to rem calculations done automatically via a preprocessor like Stylus / Sass / Less, or a postprocessor like PostCSS with the PXtoRem plugin. Use % for font-size","title":"Css"},{"location":"frontend/css/#px-em-rem","text":"Use em only for sizing that needs to scale based on the font size of an element other than the html (root) element. Use rem unit for elements that scale depending on a user's browser font size settings. Use rem as the unit for most of your property value. For complex layout arrangement, use percentage ( % ). User can change the font-size within the browser setting (difficult to find). This has no effect if px are used (main reason to discard px ?) Pixels are ignorant, don\u2019t use them. ? Use rem for sizes and spacing. rem and em units are computed into pixel values by the browser, based on font sizes in your design. em units are based on the font size of the element they\u2019re used on. rem units are based on the font size of the html element. em units can be influenced by font size inheritance from any parent element rem units can be influenced by font size inheritance from browser font settings. Use em units for sizing that should scale depending on the font size of an element other than the root. Use rem units for sizing that doesn\u2019t need em units, and that should scale depending on browser font size settings. Use rem units unless you\u2019re sure you need em units, including on font sizes. Use rem ? em ? units on media queries. Found both as best practices ( em seems also to work with safari) Don\u2019t use em or rem in multi column layout widths - use % instead. Don\u2019t use em or rem if scaling would unavoidably cause a layout element to break.","title":"px, em, rem?"},{"location":"frontend/css/#tip","text":"When creating layouts it\u2019s often easier to think in pixels but output in rem units. You can have pixel to rem calculations done automatically via a preprocessor like Stylus / Sass / Less, or a postprocessor like PostCSS with the PXtoRem plugin. Use % for font-size","title":"Tip"},{"location":"frontend/firebase/","text":"Firebase setup (Angular App) create firebase project online 1st Time npm install -g firebase-tools (if not already installed) your-build-command-here (ng build --prod) firebase login firebase init config as needded e.g.: simple angular hosting: Are you ready to proceed? (Y/n) = Y Which Firebase CLI features do you want to setup for this folder? = Hosting Select a default Firebase project for this directory = Your-Firebase-Project-Name What do you want to use as your public directory? = dist Configure as a single-page app (rewrite all urls to /index.html)? (y/N) = Y (File dist/index.html already exists. Overwrite? (y/N) = N) firebase deploy firebase open hosting:site redeploy: your-build-command-here (ng build --prod) firebase deploy","title":"Firebase"},{"location":"frontend/firebase/#firebase-setup-angular-app","text":"create firebase project online 1st Time npm install -g firebase-tools (if not already installed) your-build-command-here (ng build --prod) firebase login firebase init config as needded e.g.: simple angular hosting: Are you ready to proceed? (Y/n) = Y Which Firebase CLI features do you want to setup for this folder? = Hosting Select a default Firebase project for this directory = Your-Firebase-Project-Name What do you want to use as your public directory? = dist Configure as a single-page app (rewrite all urls to /index.html)? (y/N) = Y (File dist/index.html already exists. Overwrite? (y/N) = N) firebase deploy firebase open hosting:site redeploy: your-build-command-here (ng build --prod) firebase deploy","title":"Firebase setup (Angular App)"},{"location":"frontend/ngrx/","text":"NgRx You\u2019ll know when you need Flux. If you aren\u2019t sure if you need it, you don\u2019t need it Only use it when (and where) you need it. Do not duplicate the same information all over the place (e.g.: if you already have items stored you don't store the selected items but only the ids of the selected items and mereg them together) There should not be many nested levels of data Make everything readonly type User = { readonly firstName: string; readonly lastName: string; }; Don\u2019t use the store all over the place. Dumb components should not be aware of any state or how to fetch data Use selectors Don't use rxjs stuff like combineLatest to combine data from different states use selectors instead. Selectors are aware on which data they rely and can there for optimize there recalculation. Often Facades are used to abstract the store but they often lead to the lack of selectors (e.g.: Combining data from two facades) selector properties can be initialized directly when defining them instead of in the constructor export class DocumentContainer { companyName$ = this.store.select(detailsSelector.getDocumentCompanyName); documentStatus$ = this.store.select(detailsSelector.getDocumentStatus); constructor(private store: Store<AppStore.AppState>) { // no need to do the initialization in here } } Actions should be unique and should be used for one specific purpose onl. Hiding action dipatching behind Facades leads to reuse of Actions which is usually a bad thing since it gets more difficult to follow the data stream (which call did update the store?). What do we put in the store When... state needs to be shared between different root components (rendered inside a router-outlet) state that needs to be kept when navigating. e.g.: Sidebar state Panel state complex state the state gets updated from different sources (forntend and backend (e.g. with sockets)) We shouldn\u2019t put things in the store just because we can If that component state does not affect anything from the application state, it does not need to be on the application state or touch redux. State that is being shared between components can sometimes be kept in the parent component for instance Reducers Reducers should be very simple (think of refactoring otherwise) Effects Always handle errors The actions stream (effects) is an Observable, this means that once an error occurs it\u2019s done. This means making requests on a different stream that we then merge with operators like switchMap and always handle errors there. loadDocuments$ = this.actions$.pipe( ofType<documentActions.Fetch>(documentActions.FETCH) switchMap(() => this.documentsService.getDocuments().pipe( map(docs => new documentActions.FetchSuccess(docs)), // handle error here so the actions$ stream will not be broken catchError(err => of(new documentActions.FetchFailed())) ) ) )","title":"NgRx"},{"location":"frontend/ngrx/#ngrx","text":"You\u2019ll know when you need Flux. If you aren\u2019t sure if you need it, you don\u2019t need it Only use it when (and where) you need it. Do not duplicate the same information all over the place (e.g.: if you already have items stored you don't store the selected items but only the ids of the selected items and mereg them together) There should not be many nested levels of data Make everything readonly type User = { readonly firstName: string; readonly lastName: string; }; Don\u2019t use the store all over the place. Dumb components should not be aware of any state or how to fetch data Use selectors Don't use rxjs stuff like combineLatest to combine data from different states use selectors instead. Selectors are aware on which data they rely and can there for optimize there recalculation. Often Facades are used to abstract the store but they often lead to the lack of selectors (e.g.: Combining data from two facades) selector properties can be initialized directly when defining them instead of in the constructor export class DocumentContainer { companyName$ = this.store.select(detailsSelector.getDocumentCompanyName); documentStatus$ = this.store.select(detailsSelector.getDocumentStatus); constructor(private store: Store<AppStore.AppState>) { // no need to do the initialization in here } } Actions should be unique and should be used for one specific purpose onl. Hiding action dipatching behind Facades leads to reuse of Actions which is usually a bad thing since it gets more difficult to follow the data stream (which call did update the store?).","title":"NgRx"},{"location":"frontend/ngrx/#what-do-we-put-in-the-store","text":"When... state needs to be shared between different root components (rendered inside a router-outlet) state that needs to be kept when navigating. e.g.: Sidebar state Panel state complex state the state gets updated from different sources (forntend and backend (e.g. with sockets)) We shouldn\u2019t put things in the store just because we can If that component state does not affect anything from the application state, it does not need to be on the application state or touch redux. State that is being shared between components can sometimes be kept in the parent component for instance","title":"What do we put in the store"},{"location":"frontend/ngrx/#reducers","text":"Reducers should be very simple (think of refactoring otherwise)","title":"Reducers"},{"location":"frontend/ngrx/#effects","text":"Always handle errors The actions stream (effects) is an Observable, this means that once an error occurs it\u2019s done. This means making requests on a different stream that we then merge with operators like switchMap and always handle errors there. loadDocuments$ = this.actions$.pipe( ofType<documentActions.Fetch>(documentActions.FETCH) switchMap(() => this.documentsService.getDocuments().pipe( map(docs => new documentActions.FetchSuccess(docs)), // handle error here so the actions$ stream will not be broken catchError(err => of(new documentActions.FetchFailed())) ) ) )","title":"Effects"},{"location":"frontend/rxjs/","text":"Rxjs // Following 3 obserable creations are equal const appleStream = new Observable(appleObserver => { appleObserver.next('Apple 1'); appleObserver.next('Apple 2'); appleObserver.complete(); }); // Equivalent to... const appleStream = of('Apple 1', 'Apple 2'); // this stream get completed too // And equivalent to... const appleStream = from(['Apple 1', 'Apple 2']); // this stream get completed too Reusable pipes export const selectFilteredValues = pipe( select(selectValues), filter(val => val !== undefined) ); store.pipe(selectFilteredValues).subscribe(/* .. */); Cold Observables Imagine watching a movie on Netflix. You decide when to watch (subscribe) and what to watch. Every person gets its own 'verion' of the movie every subscription triggers the producer of the stream .share() makes the observable hot .shareReplay(1) same as .share() but the last value is kept and can therefore be accessed by late subscribers Hot Observables Imagine watching a movie in a cinema. The movie runs with or without you. When you join the cinema (subscribe) the movie might already be runnin and you missed the beginning. Every person gets the same 'version' of the movie.","title":"Rxjs"},{"location":"frontend/rxjs/#rxjs","text":"// Following 3 obserable creations are equal const appleStream = new Observable(appleObserver => { appleObserver.next('Apple 1'); appleObserver.next('Apple 2'); appleObserver.complete(); }); // Equivalent to... const appleStream = of('Apple 1', 'Apple 2'); // this stream get completed too // And equivalent to... const appleStream = from(['Apple 1', 'Apple 2']); // this stream get completed too","title":"Rxjs"},{"location":"frontend/rxjs/#reusable-pipes","text":"export const selectFilteredValues = pipe( select(selectValues), filter(val => val !== undefined) ); store.pipe(selectFilteredValues).subscribe(/* .. */);","title":"Reusable pipes"},{"location":"frontend/rxjs/#cold-observables","text":"Imagine watching a movie on Netflix. You decide when to watch (subscribe) and what to watch. Every person gets its own 'verion' of the movie every subscription triggers the producer of the stream .share() makes the observable hot .shareReplay(1) same as .share() but the last value is kept and can therefore be accessed by late subscribers","title":"Cold Observables"},{"location":"frontend/rxjs/#hot-observables","text":"Imagine watching a movie in a cinema. The movie runs with or without you. When you join the cinema (subscribe) the movie might already be runnin and you missed the beginning. Every person gets the same 'version' of the movie.","title":"Hot Observables"},{"location":"frontend/snippets/","text":"Some useful code snippets JS js - nameof // very simple nameof version to ensure type safety. usage: nameof<User>(\u2018name\u2019) export function nameof<T>(key: keyof T, instance?: T): keyof T { return key; } js - guid export function guid() { function s4() { return Math.floor((1 + Math.random()) * 0x10000) .toString(16) .substring(1); } return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + s4() + s4(); } rxjs rxjs - untilDestroy - operator import { MonoTypeOperatorFunction, Observable } from \"rxjs\"; import { takeUntil } from \"rxjs/operators\"; // create a symbol identify the observable I add to // the component so it doesn't conflict with anything. // I need this so I'm able to add the desired behaviour to the component. export const destroy$ = Symbol(\"destroy$\"); /** * An operator that takes until destroy it takes a components this a parameter * returns a pipeable RxJS operator. */ export const untilDestroy = <T>(component: any): MonoTypeOperatorFunction<T> => { const orignalDestroy = component.ngOnDestroy; if (orignalDestroy == null) { // Angular does not support dynamic added destroy methods // so make sure there is one. throw new Error(\"untilDestroy operator needs the component to have an ngOnDestroy method\"); } if (component[destroy$] === undefined) { // only hookup each component once. addDestroyObservableToComponent(component); } // pipe in the takeUntil destroy$ and return the source unaltered return takeUntil<T>(component[destroy$]); }; /** * @internal */ export function addDestroyObservableToComponent(component: any) { component[destroy$] = new Observable<void>((observer) => { // keep track of the original destroy function, // the user might do something in there const orignalDestroy = component.ngOnDestroy; // replace the ngOndestroy component.ngOnDestroy = () => { // fire off the destroy observable observer.next(); // complete the observable observer.complete(); // and at last, call the original destroy orignalDestroy.call(component); }; // return cleanup function. return (_: any) => (component[destroy$] = undefined); }); } rxjs - isTruthy - operator // same behaviour like filter(Boolean) but keeps the type. // Maybe \"is not null nor undefined\" check would be better then isTruthy (which e.g. also filters true, '' or 0) // but for legacy reasons we use that instead. export function isTruthy<T>(): MonoTypeOperatorFunction<T> { return (source$: Observable<null | undefined | T>) => source$.pipe(filter(inputIsTruthy)); } function inputIsTruthy<T>(input: null | undefined | T): boolean { return !!input; } rxjs - firstTruthy - operator function firstTruthy<T>(): MonoTypeOperatorFunction<T> { return input$ => input$.pipe(first(Boolean)); } rxjs - isNotNullNorUndefined - operator export function isNotNullNorUndefined<T>(): MonoTypeOperatorFunction<T> { return (source$: Observable<null | undefined | T>) => source$.pipe(filter(inputIsNotNullNorUndefined)); } function inputIsNotNullNorUndefined<T>(input: null | undefined | T): boolean { return input !== null && input !== undefined; } rxjs - log - operator export function log<T>(id: string = null, uniqueColor: boolean = true): MonoTypeOperatorFunction<T> { const tag = `Stream: ${id || guid()}`; let color = `color: #000000;`; if (uniqueColor) { const r = \"88\"; const g = Math.floor(Math.random() * 256).toString(16); const b = Math.floor(Math.random() * 256).toString(16); color = `color: #${r}${g}${b}`; } return pipe( tap( (next) => console.log(`%c[${tag}: Next]`, color, next), (error) => console.log(`%c${tag}: Error]`, uniqueColor ? color : \"color: #F44336;\", error), () => console.log(`%c[${tag}: Complete]`, color) ), finalize(() => console.log(`%c[${tag}: Finalize]`, color)) ); } ## Angular Angular - ngLet - Directive import { NgModule, Directive, Input, TemplateRef, ViewContainerRef, OnInit } from \"@angular/core\"; export class NgLetContext { $implicit: any = null; ngLet: any = null; } @Directive({ selector: \"[ngLet]\", }) export class NgLetDirective implements OnInit { private _context = new NgLetContext(); @Input() set ngLet(value: any) { this._context.$implicit = this._context.ngLet = value; } constructor(private _vcr: ViewContainerRef, private _templateRef: TemplateRef<NgLetContext>) {} ngOnInit() { this._vcr.createEmbeddedView(this._templateRef, this._context); } } @NgModule({ declarations: [NgLetDirective], exports: [NgLetDirective], }) export class NgLetModule {} Angular - Tooltip - Directive import { Directive, ElementRef, HostListener, Input, Renderer2 } from '@angular/core'; @Directive({ selector: '[tooltipIfEllipsisActive]' }) export class TooltipDirective { @Input() target: any; @Input() offset = 15; tooltip: HTMLElement; constructor( private renderer: Renderer2, private hostElement: ElementRef) { } @HostListener('mouseenter') onMouseEnter(): void { if (!this.tooltip && this.isEllipsisActive()) { const text = this.target.value ?? this.target.innerText; this.tooltip = this.createTooltip(text); this.positionTooltip(this.target, this.tooltip, this.offset); } } @HostListener('mouseleave') onMouseLeave(): void { if (this.tooltip) { this.renderer.removeChild(this.hostElement, this.tooltip); this.tooltip = undefined; } } private isEllipsisActive(): boolean { return this.target?.offsetWidth < this.target?.scrollWidth; } private createTooltip(text: string): HTMLElement { const tooltip = this.renderer.createElement('span'); const content = this.renderer.createText(text); this.renderer.addClass(tooltip, 'mat-tooltip'); this.renderer.setStyle(tooltip, 'color', 'white'); this.renderer.setStyle(tooltip, 'position', 'fixed'); this.renderer.setStyle(tooltip, 'text-overflow', 'unset'); this.renderer.setStyle(tooltip, 'max-width', 'unset'); this.renderer.setStyle(tooltip, 'margin', '0'); this.renderer.setStyle(tooltip, 'padding', '6px 8px'); this.renderer.setStyle(tooltip, 'border-radius', '4px'); this.renderer.setStyle(tooltip, 'top', `0px`); this.renderer.setStyle(tooltip, 'left', `0px`); this.renderer.appendChild(this.hostElement.nativeElement, tooltip); this.renderer.appendChild(tooltip, content); return tooltip; } private positionTooltip(target: Element, tooltip: Element, offset: number): void { const targetPos = target.getBoundingClientRect(); const tooltipPos = tooltip.getBoundingClientRect(); const top = targetPos.top - tooltipPos.height - offset; const left = targetPos.left + (targetPos.width - tooltipPos.width) / 2; this.renderer.setStyle(tooltip, 'top', `${top}px`); this.renderer.setStyle(tooltip, 'left', `${left}px`); } } <mat-form-field tooltipIfEllipsisActive [target]=\"input\"> <input #input> Angular - Ellipsis - Pipe import { Pipe, PipeTransform } from \"@angular/core\"; /** * Truncates text accordingly */ @Pipe({ name: \"ellipsis\", }) export class EllipsisPipe implements PipeTransform { transform(str: string, strLength: number = 250): string | null { if (str == null) { return null; } const withoutHtml = str.replace(/(<([^>]+)>)/gi, \"\"); if (str.length >= strLength) { return `${withoutHtml.slice(0, strLength)}...`; } return withoutHtml; } } Angular - OpenExternalWindow - Service import { Inject, Injectable } from \"@angular/core\"; import { WindowToken } from \"src/app/core/window/window\"; /** * Service to open an external website */ @Injectable() export class OpenExternalWindowService { constructor(@Inject(WindowToken) private window: Window) {} openExternalWindowService(helpUrl: string): void { let url = \"\"; if (!/^http[s]?:\\/\\//.test(helpUrl) && !helpUrl.toLowerCase().startsWith(\"file://\")) { url += \"https://\"; } url += helpUrl; this.window.open(url, \"_blank\"); } }","title":"Snippets"},{"location":"frontend/snippets/#some-useful-code-snippets","text":"","title":"Some useful code snippets"},{"location":"frontend/snippets/#js","text":"js - nameof // very simple nameof version to ensure type safety. usage: nameof<User>(\u2018name\u2019) export function nameof<T>(key: keyof T, instance?: T): keyof T { return key; } js - guid export function guid() { function s4() { return Math.floor((1 + Math.random()) * 0x10000) .toString(16) .substring(1); } return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" + s4() + s4() + s4(); }","title":"JS"},{"location":"frontend/snippets/#rxjs","text":"rxjs - untilDestroy - operator import { MonoTypeOperatorFunction, Observable } from \"rxjs\"; import { takeUntil } from \"rxjs/operators\"; // create a symbol identify the observable I add to // the component so it doesn't conflict with anything. // I need this so I'm able to add the desired behaviour to the component. export const destroy$ = Symbol(\"destroy$\"); /** * An operator that takes until destroy it takes a components this a parameter * returns a pipeable RxJS operator. */ export const untilDestroy = <T>(component: any): MonoTypeOperatorFunction<T> => { const orignalDestroy = component.ngOnDestroy; if (orignalDestroy == null) { // Angular does not support dynamic added destroy methods // so make sure there is one. throw new Error(\"untilDestroy operator needs the component to have an ngOnDestroy method\"); } if (component[destroy$] === undefined) { // only hookup each component once. addDestroyObservableToComponent(component); } // pipe in the takeUntil destroy$ and return the source unaltered return takeUntil<T>(component[destroy$]); }; /** * @internal */ export function addDestroyObservableToComponent(component: any) { component[destroy$] = new Observable<void>((observer) => { // keep track of the original destroy function, // the user might do something in there const orignalDestroy = component.ngOnDestroy; // replace the ngOndestroy component.ngOnDestroy = () => { // fire off the destroy observable observer.next(); // complete the observable observer.complete(); // and at last, call the original destroy orignalDestroy.call(component); }; // return cleanup function. return (_: any) => (component[destroy$] = undefined); }); } rxjs - isTruthy - operator // same behaviour like filter(Boolean) but keeps the type. // Maybe \"is not null nor undefined\" check would be better then isTruthy (which e.g. also filters true, '' or 0) // but for legacy reasons we use that instead. export function isTruthy<T>(): MonoTypeOperatorFunction<T> { return (source$: Observable<null | undefined | T>) => source$.pipe(filter(inputIsTruthy)); } function inputIsTruthy<T>(input: null | undefined | T): boolean { return !!input; } rxjs - firstTruthy - operator function firstTruthy<T>(): MonoTypeOperatorFunction<T> { return input$ => input$.pipe(first(Boolean)); } rxjs - isNotNullNorUndefined - operator export function isNotNullNorUndefined<T>(): MonoTypeOperatorFunction<T> { return (source$: Observable<null | undefined | T>) => source$.pipe(filter(inputIsNotNullNorUndefined)); } function inputIsNotNullNorUndefined<T>(input: null | undefined | T): boolean { return input !== null && input !== undefined; } rxjs - log - operator export function log<T>(id: string = null, uniqueColor: boolean = true): MonoTypeOperatorFunction<T> { const tag = `Stream: ${id || guid()}`; let color = `color: #000000;`; if (uniqueColor) { const r = \"88\"; const g = Math.floor(Math.random() * 256).toString(16); const b = Math.floor(Math.random() * 256).toString(16); color = `color: #${r}${g}${b}`; } return pipe( tap( (next) => console.log(`%c[${tag}: Next]`, color, next), (error) => console.log(`%c${tag}: Error]`, uniqueColor ? color : \"color: #F44336;\", error), () => console.log(`%c[${tag}: Complete]`, color) ), finalize(() => console.log(`%c[${tag}: Finalize]`, color)) ); } ##","title":"rxjs"},{"location":"frontend/snippets/#angular","text":"Angular - ngLet - Directive import { NgModule, Directive, Input, TemplateRef, ViewContainerRef, OnInit } from \"@angular/core\"; export class NgLetContext { $implicit: any = null; ngLet: any = null; } @Directive({ selector: \"[ngLet]\", }) export class NgLetDirective implements OnInit { private _context = new NgLetContext(); @Input() set ngLet(value: any) { this._context.$implicit = this._context.ngLet = value; } constructor(private _vcr: ViewContainerRef, private _templateRef: TemplateRef<NgLetContext>) {} ngOnInit() { this._vcr.createEmbeddedView(this._templateRef, this._context); } } @NgModule({ declarations: [NgLetDirective], exports: [NgLetDirective], }) export class NgLetModule {} Angular - Tooltip - Directive import { Directive, ElementRef, HostListener, Input, Renderer2 } from '@angular/core'; @Directive({ selector: '[tooltipIfEllipsisActive]' }) export class TooltipDirective { @Input() target: any; @Input() offset = 15; tooltip: HTMLElement; constructor( private renderer: Renderer2, private hostElement: ElementRef) { } @HostListener('mouseenter') onMouseEnter(): void { if (!this.tooltip && this.isEllipsisActive()) { const text = this.target.value ?? this.target.innerText; this.tooltip = this.createTooltip(text); this.positionTooltip(this.target, this.tooltip, this.offset); } } @HostListener('mouseleave') onMouseLeave(): void { if (this.tooltip) { this.renderer.removeChild(this.hostElement, this.tooltip); this.tooltip = undefined; } } private isEllipsisActive(): boolean { return this.target?.offsetWidth < this.target?.scrollWidth; } private createTooltip(text: string): HTMLElement { const tooltip = this.renderer.createElement('span'); const content = this.renderer.createText(text); this.renderer.addClass(tooltip, 'mat-tooltip'); this.renderer.setStyle(tooltip, 'color', 'white'); this.renderer.setStyle(tooltip, 'position', 'fixed'); this.renderer.setStyle(tooltip, 'text-overflow', 'unset'); this.renderer.setStyle(tooltip, 'max-width', 'unset'); this.renderer.setStyle(tooltip, 'margin', '0'); this.renderer.setStyle(tooltip, 'padding', '6px 8px'); this.renderer.setStyle(tooltip, 'border-radius', '4px'); this.renderer.setStyle(tooltip, 'top', `0px`); this.renderer.setStyle(tooltip, 'left', `0px`); this.renderer.appendChild(this.hostElement.nativeElement, tooltip); this.renderer.appendChild(tooltip, content); return tooltip; } private positionTooltip(target: Element, tooltip: Element, offset: number): void { const targetPos = target.getBoundingClientRect(); const tooltipPos = tooltip.getBoundingClientRect(); const top = targetPos.top - tooltipPos.height - offset; const left = targetPos.left + (targetPos.width - tooltipPos.width) / 2; this.renderer.setStyle(tooltip, 'top', `${top}px`); this.renderer.setStyle(tooltip, 'left', `${left}px`); } } <mat-form-field tooltipIfEllipsisActive [target]=\"input\"> <input #input> Angular - Ellipsis - Pipe import { Pipe, PipeTransform } from \"@angular/core\"; /** * Truncates text accordingly */ @Pipe({ name: \"ellipsis\", }) export class EllipsisPipe implements PipeTransform { transform(str: string, strLength: number = 250): string | null { if (str == null) { return null; } const withoutHtml = str.replace(/(<([^>]+)>)/gi, \"\"); if (str.length >= strLength) { return `${withoutHtml.slice(0, strLength)}...`; } return withoutHtml; } } Angular - OpenExternalWindow - Service import { Inject, Injectable } from \"@angular/core\"; import { WindowToken } from \"src/app/core/window/window\"; /** * Service to open an external website */ @Injectable() export class OpenExternalWindowService { constructor(@Inject(WindowToken) private window: Window) {} openExternalWindowService(helpUrl: string): void { let url = \"\"; if (!/^http[s]?:\\/\\//.test(helpUrl) && !helpUrl.toLowerCase().startsWith(\"file://\")) { url += \"https://\"; } url += helpUrl; this.window.open(url, \"_blank\"); } }","title":"Angular"},{"location":"misc/beautifulCode/","text":"Writing Beatiful Code The ratio between reading code and writing code is roughly 10:1! Simplicity Simplicity is the best way to meassure code quality Code Traversal: When the code traversal is easy, the code is simple to follow. How easy it is to navigate through the code? Is it easy to spot where the API functions are written? Is it easy to understand call flows, for example which methods are calling others (and why)- are there good state machines implemented or cleanly identified algorithms? Make the Simplest Thing that could possibly work. Implement a new feature in the simplest way you can think of that \"could possibly work\". Make the code pass the Unit Tests. Refactor the system to be the simplest possible code including all the features it now has. YAGNI Always implement things when you actually need them, never when you just foresee that you need them. Cohesion Stuff that changes together should live together (e.g.: achieved with layering) Release Early, Release Often and You'll Start to Write Better Code Or briefly put: shorten your release cycles! This way: your team will handle priorities much better than if you released only one time a year, for instance as for you, you'll get to learn more about your code and your users \u2026 as time spent on development tools, on scripts, on your build, is never a wasted time: it leads to high quality, clean and usable code Write Pure Functions Makes your code easier to read and easier to test. Comments Usually we write comments when the intent of the code is not clear. Instead of writing comments we should ask ourselves => Can I write the code better? Comments are often lies.","title":"Writing Beatiful Code"},{"location":"misc/beautifulCode/#writing-beatiful-code","text":"The ratio between reading code and writing code is roughly 10:1!","title":"Writing Beatiful Code"},{"location":"misc/beautifulCode/#simplicity","text":"Simplicity is the best way to meassure code quality","title":"Simplicity"},{"location":"misc/beautifulCode/#code-traversal","text":"When the code traversal is easy, the code is simple to follow. How easy it is to navigate through the code? Is it easy to spot where the API functions are written? Is it easy to understand call flows, for example which methods are calling others (and why)- are there good state machines implemented or cleanly identified algorithms?","title":"Code Traversal:"},{"location":"misc/beautifulCode/#make-the-simplest-thing-that-could-possibly-work","text":"Implement a new feature in the simplest way you can think of that \"could possibly work\". Make the code pass the Unit Tests. Refactor the system to be the simplest possible code including all the features it now has.","title":"Make the Simplest Thing that could possibly work."},{"location":"misc/beautifulCode/#yagni","text":"Always implement things when you actually need them, never when you just foresee that you need them.","title":"YAGNI"},{"location":"misc/beautifulCode/#cohesion","text":"Stuff that changes together should live together (e.g.: achieved with layering)","title":"Cohesion"},{"location":"misc/beautifulCode/#release-early-release-often-and-youll-start-to-write-better-code","text":"Or briefly put: shorten your release cycles! This way: your team will handle priorities much better than if you released only one time a year, for instance as for you, you'll get to learn more about your code and your users \u2026 as time spent on development tools, on scripts, on your build, is never a wasted time: it leads to high quality, clean and usable code","title":"Release Early, Release Often and You'll Start to Write Better Code"},{"location":"misc/beautifulCode/#write-pure-functions","text":"Makes your code easier to read and easier to test.","title":"Write Pure Functions"},{"location":"misc/beautifulCode/#comments","text":"Usually we write comments when the intent of the code is not clear. Instead of writing comments we should ask ourselves => Can I write the code better? Comments are often lies.","title":"Comments"},{"location":"misc/github/","text":"Github Action Example > Build and Deploy Gatsby page to gh-pages Generate a token on Github (select repo): https://github.com/settings/tokens Copy token and insert as new Secret in the repository where you like to use it. Create action (se example) on: push: branches: - main name: Build and Deploy Gatsby jobs: build_gatsby: name: build runs-on: ubuntu-latest steps: - uses: actions/checkout@v1 - name: yarn install run: yarn install - name: gatsby build env: GH_API_KEY: ${{ secrets.YOUR_SECRET_NAME }} run: yarn build - name: deploy uses: maxheld83/ghpages@v0.2.1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} GH_PAT: ${{ secrets.YOUR_SECRET_NAME }} BUILD_DIR: \"public/\"","title":"GitHub"},{"location":"misc/github/#github","text":"","title":"Github"},{"location":"misc/github/#action","text":"Example > Build and Deploy Gatsby page to gh-pages Generate a token on Github (select repo): https://github.com/settings/tokens Copy token and insert as new Secret in the repository where you like to use it. Create action (se example) on: push: branches: - main name: Build and Deploy Gatsby jobs: build_gatsby: name: build runs-on: ubuntu-latest steps: - uses: actions/checkout@v1 - name: yarn install run: yarn install - name: gatsby build env: GH_API_KEY: ${{ secrets.YOUR_SECRET_NAME }} run: yarn build - name: deploy uses: maxheld83/ghpages@v0.2.1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} GH_PAT: ${{ secrets.YOUR_SECRET_NAME }} BUILD_DIR: \"public/\"","title":"Action"},{"location":"misc/pitch/","text":"How to Pitch Ambition Why? Goal, Motivation","title":"Pitch"},{"location":"misc/pitch/#how-to-pitch","text":"","title":"How to Pitch"},{"location":"misc/pitch/#ambition","text":"Why? Goal, Motivation","title":"Ambition"},{"location":"misc/rest/","text":"Idempotent A request method is considered \"idempotent\" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. The HTTP specification states that following methods must be idempotent . GET PUT DELETE But following methods are not guaranteed to be idempotent . POST","title":"REST"},{"location":"misc/rest/#idempotent","text":"A request method is considered \"idempotent\" if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request. The HTTP specification states that following methods must be idempotent . GET PUT DELETE But following methods are not guaranteed to be idempotent . POST","title":"Idempotent"}]}